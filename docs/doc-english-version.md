# 📄 Technical Documentation — Intelligent .NET Commit Analysis with AI

## 1. 🎯 Overview

This project implements an **automated agent** for intelligent commit analysis in **.NET repositories** hosted on GitHub.

Whenever a commit is detected, the agent:

1. Captures the code *diff*.
2. Sends it to an **AI service (Gemini Mini)** for analysis.
3. Receives a report with potential issues.
4. Automatically creates an *issue* in the repository with the results.

The goal is to **improve code quality** and **reduce production failures** by embedding AI into the development workflow.

---

## 2. 🧱 System Architecture

```plaintext
GitHub Commit → GitHub Actions → Capture Diff → AI (Gemini Mini) → Report → Create Issue
```

### Main Components

| Component           | Responsibility                                            |
| ------------------- | --------------------------------------------------------- |
| **GitHub Actions**  | Detects commits and triggers the analysis pipeline        |
| **Diff Script**     | Extracts changes using `git diff` or GitHub API           |
| **AI Integration**  | Sends the diff to Gemini Mini API and receives the report |
| **Issue Generator** | Creates a GitHub issue with the analysis results          |

---

## 3. ⚙️ Technologies

* **GitHub Actions** → CI/CD automation
* **.NET (C#)** → Base repository language
* **Gemini Mini API** → Intelligent code analysis
* **Python / Node.js** → Integration scripts (flexible choice)
* **GitHub REST API** → Automated issue creation
* **GitHub Secrets** → Secure storage for API keys and tokens

---

## 4. 📂 Directory Structure

```
.github/
└── workflows/
    └── analyze-commit.yml    # GitHub Actions workflow

scripts/
├── analyze_diff.py (or .js)  # Captures diff and calls AI
└── create_issue.py (or .js)  # Creates GitHub issue

README.md
```

---

## 5. 🔄 Execution Flow

### 5.1. Workflow (`analyze-commit.yml`)

```yaml
on:
  push:
    branches:
      - main
      - develop

jobs:
  analyze:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Install dependencies
        run: pip install requests  # or npm install

      - name: Run analysis
        run: python scripts/analyze_diff.py
```

### 5.2. Analysis Script (`analyze_diff.py`)

* Captures the commit diff.
* Prepares the analysis prompt.
* Sends it to the AI API.
* Receives a structured report.

### 5.3. Issue Creation Script (`create_issue.py`)

* Formats the report into **Markdown**.
* Creates a GitHub issue.
* Adds severity labels (`critical`, `high`, `medium`, `low`).

---

## 6. 🧠 AI Prompt

```plaintext
Analyze the following .NET code diff.  
Classify potential issues as: Critical, High, Medium, Low.  
Briefly explain each one.  
Return the result in structured Markdown format.  
```

---

## 7. 🔐 Secrets Configuration

In GitHub repository settings, configure the following **secrets**:

* `GEMINI_API_KEY` → Gemini Mini API access key
* `GH_TOKEN` → GitHub token with issue creation permissions

---

## 8. 📋 Example of Generated Issue

```markdown
## Commit Analysis Report

**Commit:** abc123  
**Branch:** main  
**Author:** @nathalia  

### ⚠️ Detected Issues
- **Critical:** Use of `Thread.Sleep` in async environment  
- **High:** Missing input validation in public method  
- **Medium:** Outdated comments  
- **Low:** Non-descriptive variable name  

_Automatically generated by AI._ 🤖
```

---

## 9. ✅ Testing & Validation

* Simulated commits with intentional issues
* Verification of correct issue creation
* Iterative tuning of the AI prompt to improve accuracy

---

## 10. 🚀 Future Improvements

* **Multi-language support** beyond .NET
* **Pull Request analysis** before merge (high priority)
* **Automated fix suggestions**
* **Integration with quality tools** (SonarQube, CodeQL, etc.)
* **Observability** → Monitoring AI response times and error rates

---

👉 Now your project looks **portfolio-ready** in English, easy to understand for recruiters, collaborators, or even international open-source contributors.

Quer que eu também faça uma versão **curtinha e executiva** (1 página estilo "project summary") para você colocar no início do repositório como README principal?
